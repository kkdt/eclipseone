/**
 * MIT License
 * Copyright (c) 2017 kkdt
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

apply plugin : 'eclipse'
apply plugin : 'java'

/**
 * Declare repositories in root project so that it knows to download dependencies
 * when building eclipse artifacts.
 */
repositories {
   mavenCentral()
}

ext {
   localLib = project.projectDir.path + File.separator + 'lib'
}

/**
 * Common subproject definitions.
 */
subprojects {
   apply plugin: 'java'
   group = 'org.gradle.sample'
   version = '1.0'

   repositories {
      mavenCentral()
   }

   // Define eclipse-specific configurations so that root project knows to
   // process them during eclipse plugin tasks
   configurations {
      eclipseLibs {
         description 'All library dependencies for subproject'
      }

      eclipseSources {
         description 'All source directories for subproject'
      }
   }

   dependencies {
      testCompile "junit:junit:4.12"

      // include not only compile but also test classpath for eclipse
      eclipseLibs configurations.testCompileClasspath

      // gather up all source files for each subproject
      eclipseSources files(sourceSets.collect().collect {
         it.java.srcDirs + it.resources.srcDirs
      })
   }

   task projectLibs(description: 'Library dependencies for testCompile configuration') {
      doLast {
         println project.name + ' ' + project.configurations.testCompile.files.collect()
      }
   }
   
   task stage(type: Copy, description: 'Stage only runtime library dependencies') {
      into rootProject.localLib
      from configurations.runtime
   }
   
   task stageAll(type: Copy, description: 'Stage testCompile library dependencies') {
      into rootProject.localLib
      from configurations.testCompile
   }
   
   task cleanAll(description: 'Clean all artifacts created by this project build', dependsOn: ['clean']) {
      doLast {
         delete localLib
      }
   }
}

project(':api') {
   dependencies {
      compile project(':shared')

      // this dependency was added as an example
      compile "javax.servlet:servlet-api:2.5"
   }
}

project(':services:personService') {
   dependencies {
      compile project(':shared'), project(':api')

      // this dependency was added as an example
      compile 'com.amazonaws:aws-lambda-java-core:1.1.0'
   }
}

eclipse {
   classpath {
      //plusConfigurations += [ configurations.eclipseLibs ]

      file.whenMerged { classpath ->

         // subproject jar files will be ignored
         def archives = subprojects.findAll { project ->
            project.plugins.hasPlugin('java')
         }.collect { project ->
            project.jar.archivePath
         }.collect() as Set

         subprojects.findAll { project ->
            project.plugins.hasPlugin('java')
         }.collect { project ->
            project.configurations.eclipseSources.each {
               if(file(it).exists()) {
                  def src = new org.gradle.plugins.ide.eclipse.model.SourceFolder(rootProject.relativePath(it.absolutePath), null)
                  classpath.entries += src
               }
            }
         }

         subprojects.findAll { project ->
            project.plugins.hasPlugin('java')
         }.collect { project ->
            project.configurations.eclipseLibs.each {
               def fileRef = fileReference(it)
               def lib = new org.gradle.plugins.ide.eclipse.model.Library(fileRef)
               lib.exported = true

               if(!classpath.entries.contains(lib) && !archives.contains(fileRef.file)) {
                  classpath.entries += lib
               }
            }
         }
      }
   }
}

/**
 * All library dependencies for root project, excluding jar artifacts that each
 * subproject builds.
 *
 * @return a set of file(s) to library dependencies.
 */
def allLibs() {
   // find all subproject jar files
   def archives = subprojects.findAll { project ->
      project.plugins.hasPlugin('java')
   }.collect { project ->
      project.jar.archivePath
   }.collect() as Set

   def allLibs = [] as Set

   allLibs += subprojects.findAll { project ->
      project.plugins.hasPlugin('java')
   }.collect { project ->
      project.configurations.testCompile.files.collect()
   }.flatten()

   // do not include subproject jar files
   return allLibs.minus(archives)
}

task sources(description:'Prints all java sources for each subproject(s)') {
   doLast {
      subprojects.findAll { project ->
         project.plugins.hasPlugin('java')
      }.collect { project ->
         print project

         def sources = project.sourceSets.collect()
         println ' ' + sources.collect {
            it.java.srcDirs
         }
      }
   }
}

task libraries(description:'Print all libraries of subproject(s)') {
   doLast {
      println ' allLibs: ' + allLibs().each { it }
   }
}

task subprojectInfo(description: 'Information about subproject(s)') {
   doLast {
      subprojects.findAll { project ->
         project.plugins.hasPlugin('java')
      }.collect { project ->
         println project.name + ': ' + project.jar.archiveName
         // archive full path
         println '   ' + project.jar.archivePath
         // display configurations
         project.configurations.each {
            println '   ' + it + ' ' + it.description
         }
      }
   }
}
